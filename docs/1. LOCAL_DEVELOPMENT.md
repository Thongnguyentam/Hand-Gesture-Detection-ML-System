# 1. Local Development & Testing Guide

This guide provides commands and instructions for running and testing the application on a local machine. This includes running the services directly and deploying to a local Kubernetes cluster (Minikube) to simulate the production environment.

---

## 1. Running the API Backend Locally

These steps allow you to run the FastAPI server directly on your machine for rapid development and testing.

1.  **Install Dependencies:**
    Using a virtual environment is highly recommended. `uv` is a fast, modern package manager.
    ```shell
    pip install uv
    uv sync
    ```
2.  **Create a `.env` file:**
    The application follows the 12-Factor App methodology by reading configuration from the environment. For local development, this is managed via a `.env` file.
    ```
    MONGODB_CONNECTION_URL=...
    JWT_SECRET=...
    ```

3.  **Run the FastAPI Server:**
    `uvicorn` is a high-performance ASGI server. The `--reload` flag enables hot-reloading, so the server will automatically restart when you save code changes.
    ```shell
    uvicorn main:app --reload
    ```
    The API documentation will be available at `http://127.0.0.1:8000/docs`.

---

## 2. Building a Docker Image Manually

While the CI/CD pipeline automates this process, you may want to build a Docker image locally for testing or debugging purposes.

1.  **Build the Image:**
    This command builds the Docker image based on the instructions in the `Dockerfile`.
    ```shell
    docker build -t hand-gesture-detection:v1 .
    ```

2.  **Tag and Push to Docker Hub:**
    To use the image in a Kubernetes cluster (even Minikube, sometimes), it needs to be available in a registry.
    ```shell
    # Tag the image with your Docker Hub username and a version
    docker tag hand-gesture-detection:v1 your-dockerhub-username/hand-gesture-detection:v1

    # Log in to Docker Hub
    docker login

    # Push the image to the registry
    docker push your-dockerhub-username/hand-gesture-detection:v1
    ```

---

## 3. Running the Webcam Client

The client in `app.py` can be used to send data to the API backend.

-   **To connect to a locally running API:**
    ```shell
    python app.py
    ```

-   **To connect to a deployed API in Kubernetes:**
    You must first expose the service, for example, by using the Ingress IP.
    ```shell
    python app.py --ws_url ws://<YOUR_INGRESS_IP>/api/asl/predict
    ```

---

## 4. Testing with a Local Kubernetes Cluster (Minikube)

Minikube is an essential tool that runs a single-node Kubernetes cluster on your local machine, allowing you to test your Helm charts and deployments without needing a cloud provider.

1.  **Start Minikube and Enable Ingress:**
    ```shell
    minikube start
    minikube addons enable ingress
    ```

2.  **Deploy the Application:**
    Since the pipeline isn't running, you must manually create the Kubernetes secret that the Helm chart expects.
    ```shell
    # Create a namespace to match the production environment
    kubectl create ns model-serving

    # Create a secret with placeholder values
    kubectl create secret generic hand-gesture-secrets -n model-serving \
      --from-literal=MONGODB_CONNECTION_URL='your-mongo-url' \
      --from-literal=JWT_SECRET='your-jwt-secret' \
      --from-literal=GITHUB_TOKEN='your-github-token'
    
    # Install the helm chart
    helm install hand-gesture ./helm-charts/asl -n model-serving

    # Later you can upgrade or delete the chart
    helm upgrade hand-gesture ./asl --namespace model-serving --create-namespace # upgrade helm chart
    
    helm uninstall hand-gesture -n model-serving # uninstall helm chart
    ```

3.  **Accessing the Service:**
    -   **Via Port-Forwarding:**
        This is the simplest way to get access. It directly forwards a local port to the service, bypassing the Ingress. It's great for quick debugging.
        ```shell
        kubectl port-forward svc/hand-gesture -n model-serving 30000:30000
        ```
        You can now access the service at `http://localhost:30000`.

    -   **Via Minikube Tunnel:**
        This method provides a more realistic test by exposing the Ingress controller. It's better for testing Ingress rules and the full network path.
        ```shell
        # Run this in a separate terminal
        minikube tunnel
        ```
        Then, find the `EXTERNAL-IP` of the ingress to access the service.
        ```shell
        kubectl get ingress -n model-serving
        ```

## 5. Debugging in Kubernetes

Common `kubectl` commands for checking the status of your deployed application:

-   **Check resource status:**
    ```shell
    kubectl get pods,services,ingress -n model-serving
    ```

-   **View logs from a running pod:**
    ```shell
    # Get the name of your pod first
    kubectl get pods -n model-serving
    
    # View its logs
    kubectl logs <pod-name> -n model-serving
    
    # View logs from a previous, crashed instance of the pod
    kubectl logs <pod-name> -n model-serving --previous
    ```

-   **Get detailed information about a pod's state:**
    This is very useful for debugging startup errors, as it shows events, volume mounts, and container status.
    ```shell
    kubectl describe pod <pod-name> -n model-serving
    ``` 